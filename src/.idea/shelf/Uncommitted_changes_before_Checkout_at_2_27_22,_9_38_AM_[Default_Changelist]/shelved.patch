Index: runtime/slice.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage runtime\n\nimport (\n\t\"runtime/internal/math\"\n\t\"runtime/internal/sys\"\n\t\"unsafe\"\n)\n\ntype slice struct {\n\tarray unsafe.Pointer\n\tlen   int\n\tcap   int\n}\n\n// A notInHeapSlice is a slice backed by go:notinheap memory.\ntype notInHeapSlice struct {\n\tarray *notInHeap\n\tlen   int\n\tcap   int\n}\n\nfunc panicmakeslicelen() {\n\tpanic(errorString(\"makeslice: len out of range\"))\n}\n\nfunc panicmakeslicecap() {\n\tpanic(errorString(\"makeslice: cap out of range\"))\n}\n\n// makeslicecopy allocates a slice of \"tolen\" elements of type \"et\",\n// then copies \"fromlen\" elements of type \"et\" into that new allocation from \"from\".\nfunc makeslicecopy(et *_type, tolen int, fromlen int, from unsafe.Pointer) unsafe.Pointer {\n\tvar tomem, copymem uintptr\n\tif uintptr(tolen) > uintptr(fromlen) {\n\t\tvar overflow bool\n\t\ttomem, overflow = math.MulUintptr(et.size, uintptr(tolen))\n\t\tif overflow || tomem > maxAlloc || tolen < 0 {\n\t\t\tpanicmakeslicelen()\n\t\t}\n\t\tcopymem = et.size * uintptr(fromlen)\n\t} else {\n\t\t// fromlen is a known good length providing and equal or greater than tolen,\n\t\t// thereby making tolen a good slice length too as from and to slices have the\n\t\t// same element width.\n\t\ttomem = et.size * uintptr(tolen)\n\t\tcopymem = tomem\n\t}\n\n\tvar to unsafe.Pointer\n\tif et.ptrdata == 0 {\n\t\tto = mallocgc(tomem, nil, false)\n\t\tif copymem < tomem {\n\t\t\tmemclrNoHeapPointers(add(to, copymem), tomem-copymem)\n\t\t}\n\t} else {\n\t\t// Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.\n\t\tto = mallocgc(tomem, et, true)\n\t\tif copymem > 0 && writeBarrier.enabled {\n\t\t\t// Only shade the pointers in old.array since we know the destination slice to\n\t\t\t// only contains nil pointers because it has been cleared during alloc.\n\t\t\tbulkBarrierPreWriteSrcOnly(uintptr(to), uintptr(from), copymem)\n\t\t}\n\t}\n\n\tif raceenabled {\n\t\tcallerpc := getcallerpc()\n\t\tpc := funcPC(makeslicecopy)\n\t\tracereadrangepc(from, copymem, callerpc, pc)\n\t}\n\tif msanenabled {\n\t\tmsanread(from, copymem)\n\t}\n\n\tmemmove(to, from, copymem)\n\n\treturn to\n}\n\nfunc makeslice(et *_type, len, cap int) unsafe.Pointer {\n\tmem, overflow := math.MulUintptr(et.size, uintptr(cap))\n\tif overflow || mem > maxAlloc || len < 0 || len > cap {\n\t\t// NOTE: Produce a 'len out of range' error instead of a\n\t\t// 'cap out of range' error when someone does make([]T, bignumber).\n\t\t// 'cap out of range' is true too, but since the cap is only being\n\t\t// supplied implicitly, saying len is clearer.\n\t\t// See golang.org/issue/4085.\n\t\tmem, overflow := math.MulUintptr(et.size, uintptr(len))\n\t\tif overflow || mem > maxAlloc || len < 0 {\n\t\t\tpanicmakeslicelen()\n\t\t}\n\t\tpanicmakeslicecap()\n\t}\n\n\treturn mallocgc(mem, et, true)\n}\n\nfunc makeslice64(et *_type, len64, cap64 int64) unsafe.Pointer {\n\tlen := int(len64)\n\tif int64(len) != len64 {\n\t\tpanicmakeslicelen()\n\t}\n\n\tcap := int(cap64)\n\tif int64(cap) != cap64 {\n\t\tpanicmakeslicecap()\n\t}\n\n\treturn makeslice(et, len, cap)\n}\n\n// growslice handles slice growth during append.\n// It is passed the slice element type, the old slice, and the desired new minimum capacity,\n// and it returns a new slice with at least that capacity, with the old data\n// copied into it.\n// The new slice's length is set to the old slice's length,\n// NOT to the new requested capacity.\n// This is for codegen convenience. The old slice's length is used immediately\n// to calculate where to write new values during an append.\n// TODO: When the old backend is gone, reconsider this decision.\n// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.\nfunc growslice(et *_type, old slice, cap int) slice {\n\tif raceenabled {\n\t\tcallerpc := getcallerpc()\n\t\tracereadrangepc(old.array, uintptr(old.len*int(et.size)), callerpc, funcPC(growslice))\n\t}\n\tif msanenabled {\n\t\tmsanread(old.array, uintptr(old.len*int(et.size)))\n\t}\n\n\tif cap < old.cap {\n\t\tpanic(errorString(\"growslice: cap out of range\"))\n\t}\n\n\tif et.size == 0 {\n\t\t// append should not create a slice with nil pointer but non-zero len.\n\t\t// We assume that append doesn't need to preserve old.array in this case.\n\t\treturn slice{unsafe.Pointer(&zerobase), old.len, cap}\n\t}\n\n\tnewcap := old.cap\n\tdoublecap := newcap + newcap\n\tif cap > doublecap {\n\t\tnewcap = cap\n\t} else {\n\t\tif old.len < 1024 {\n\t\t\tnewcap = doublecap\n\t\t} else {\n\t\t\t// Check 0 < newcap to detect overflow\n\t\t\t// and prevent an infinite loop.\n\t\t\tfor 0 < newcap && newcap < cap {\n\t\t\t\tnewcap += newcap / 4\n\t\t\t}\n\t\t\t// Set newcap to the requested cap when\n\t\t\t// the newcap calculation overflowed.\n\t\t\tif newcap <= 0 {\n\t\t\t\tnewcap = cap\n\t\t\t}\n\t\t}\n\t}\n\n\tvar overflow bool\n\tvar lenmem, newlenmem, capmem uintptr\n\t// Specialize for common values of et.size.\n\t// For 1 we don't need any division/multiplication.\n\t// For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant.\n\t// For powers of 2, use a variable shift.\n\tswitch {\n\tcase et.size == 1:\n\t\tlenmem = uintptr(old.len)\n\t\tnewlenmem = uintptr(cap)\n\t\tcapmem = roundupsize(uintptr(newcap))\n\t\toverflow = uintptr(newcap) > maxAlloc\n\t\tnewcap = int(capmem)\n\tcase et.size == sys.PtrSize:\n\t\tlenmem = uintptr(old.len) * sys.PtrSize\n\t\tnewlenmem = uintptr(cap) * sys.PtrSize\n\t\tcapmem = roundupsize(uintptr(newcap) * sys.PtrSize)\n\t\toverflow = uintptr(newcap) > maxAlloc/sys.PtrSize\n\t\tnewcap = int(capmem / sys.PtrSize)\n\tcase isPowerOfTwo(et.size):\n\t\tvar shift uintptr\n\t\tif sys.PtrSize == 8 {\n\t\t\t// Mask shift for better code generation.\n\t\t\tshift = uintptr(sys.Ctz64(uint64(et.size))) & 63\n\t\t} else {\n\t\t\tshift = uintptr(sys.Ctz32(uint32(et.size))) & 31\n\t\t}\n\t\tlenmem = uintptr(old.len) << shift\n\t\tnewlenmem = uintptr(cap) << shift\n\t\tcapmem = roundupsize(uintptr(newcap) << shift)\n\t\toverflow = uintptr(newcap) > (maxAlloc >> shift)\n\t\tnewcap = int(capmem >> shift)\n\tdefault:\n\t\tlenmem = uintptr(old.len) * et.size\n\t\tnewlenmem = uintptr(cap) * et.size\n\t\tcapmem, overflow = math.MulUintptr(et.size, uintptr(newcap))\n\t\tcapmem = roundupsize(capmem)\n\t\tnewcap = int(capmem / et.size)\n\t}\n\n\t// The check of overflow in addition to capmem > maxAlloc is needed\n\t// to prevent an overflow which can be used to trigger a segfault\n\t// on 32bit architectures with this example program:\n\t//\n\t// type T [1<<27 + 1]int64\n\t//\n\t// var d T\n\t// var s []T\n\t//\n\t// func main() {\n\t//   s = append(s, d, d, d, d)\n\t//   print(len(s), \"\\n\")\n\t// }\n\tif overflow || capmem > maxAlloc {\n\t\tpanic(errorString(\"growslice: cap out of range\"))\n\t}\n\n\tvar p unsafe.Pointer\n\tif et.ptrdata == 0 {\n\t\tp = mallocgc(capmem, nil, false)\n\t\t// The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).\n\t\t// Only clear the part that will not be overwritten.\n\t\tmemclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)\n\t} else {\n\t\t// Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.\n\t\tp = mallocgc(capmem, et, true)\n\t\tif lenmem > 0 && writeBarrier.enabled {\n\t\t\t// Only shade the pointers in old.array since we know the destination slice p\n\t\t\t// only contains nil pointers because it has been cleared during alloc.\n\t\t\tbulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(old.array), lenmem-et.size+et.ptrdata)\n\t\t}\n\t}\n\tmemmove(p, old.array, lenmem)\n\n\treturn slice{p, old.len, newcap}\n}\n\n// cutslice用于处理切片操作\nfunc cutslice(et *_type, old slice, i, j, k int) slice {\n\tif raceenabled {\n\t\tcallerpc := getcallerpc()\n\t\tracereadrangepc(old.array, uintptr(old.len*int(et.size)), callerpc, funcPC(growslice))\n\t}\n\tif msanenabled {\n\t\tmsanread(old.array, uintptr(old.len*int(et.size)))\n\t}\n\n\tif j > old.cap {\n\t\tpanic(errorString(\"cutslice: high out of range\"))\n\t}\n\n\tlen := (j - i)\n\n\tif et.size == 0 {\n\t\t// append should not create a slice with nil pointer but non-zero len.\n\t\t// We assume that append doesn't need to preserve old.array in this case.\n\t\treturn slice{unsafe.Pointer(&zerobase), len, len}\n\t}\n\n\tif k > 0 {\n\t\tlen /= k\n\t\tif len*k != j-i {\n\t\t\tlen++\n\t\t}\n\t} else if k < 0 {\n\t\t// 从后向前拷贝元素\n\t\told.array = unsafe.Pointer(uintptr(old.array) + uintptr(len-1)*et.size)\n\t\tlen /= -k\n\t\tif len*(-k) != j-i {\n\t\t\tlen++\n\t\t}\n\t} else {\n\t\tpanic(\"k不能为0\")\n\t}\n\n\t// 判断是否申请的空间过大导致内存溢出\n\tbytes, overflow := math.MulUintptr(et.size, uintptr(len))\n\n\tif overflow {\n\t\tpanic(errorString(\"cutslice: overflow\"))\n\t}\n\n\tvar p unsafe.Pointer\n\tif et.ptrdata == 0 {\n\t\tp = mallocgc(bytes, nil, false)\n\t} else {\n\t\t// Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.\n\t\tp = mallocgc(bytes, et, false)\n\t\t/*if lenmem > 0 && writeBarrier.enabled {\n\t\t\t// Only shade the pointers in old.array since we know the destination slice p\n\t\t\t// only contains nil pointers because it has been cleared during alloc.\n\t\t\tbulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(old.array), lenmem-et.size+et.ptrdata)\n\t\t}*/\n\t}\n\t//memmovebystep(p, old.array, et.size, uintptr(k) * et.size, uintptr(len))\n\n\treturn slice{p, len, len}\n}\n\nfunc isPowerOfTwo(x uintptr) bool {\n\treturn x&(x-1) == 0\n}\n\nfunc slicecopy(toPtr unsafe.Pointer, toLen int, fmPtr unsafe.Pointer, fmLen int, width uintptr) int {\n\tif fmLen == 0 || toLen == 0 {\n\t\treturn 0\n\t}\n\n\tn := fmLen\n\tif toLen < n {\n\t\tn = toLen\n\t}\n\n\tif width == 0 {\n\t\treturn n\n\t}\n\n\tif raceenabled {\n\t\tcallerpc := getcallerpc()\n\t\tpc := funcPC(slicecopy)\n\t\tracereadrangepc(fmPtr, uintptr(n*int(width)), callerpc, pc)\n\t\tracewriterangepc(toPtr, uintptr(n*int(width)), callerpc, pc)\n\t}\n\tif msanenabled {\n\t\tmsanread(fmPtr, uintptr(n*int(width)))\n\t\tmsanwrite(toPtr, uintptr(n*int(width)))\n\t}\n\n\tsize := uintptr(n) * width\n\tif size == 1 { // common case worth about 2x to do here\n\t\t// TODO: is this still worth it with new memmove impl?\n\t\t*(*byte)(toPtr) = *(*byte)(fmPtr) // known to be a byte pointer\n\t} else {\n\t\tmemmove(toPtr, fmPtr, size)\n\t}\n\treturn n\n}\n\nfunc slicestringcopy(toPtr *byte, toLen int, fm string) int {\n\tif len(fm) == 0 || toLen == 0 {\n\t\treturn 0\n\t}\n\n\tn := len(fm)\n\tif toLen < n {\n\t\tn = toLen\n\t}\n\n\tif raceenabled {\n\t\tcallerpc := getcallerpc()\n\t\tpc := funcPC(slicestringcopy)\n\t\tracewriterangepc(unsafe.Pointer(toPtr), uintptr(n), callerpc, pc)\n\t}\n\tif msanenabled {\n\t\tmsanwrite(unsafe.Pointer(toPtr), uintptr(n))\n\t}\n\n\tmemmove(unsafe.Pointer(toPtr), stringStructOf(&fm).str, uintptr(n))\n\treturn n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/runtime/slice.go b/runtime/slice.go
--- a/runtime/slice.go	(revision 9b075fda74fcd55105c8bd967d2cfa1a8275b356)
+++ b/runtime/slice.go	(date 1645888348865)
@@ -273,8 +273,6 @@
 		if len*(-k) != j-i {
 			len++
 		}
-	} else {
-		panic("k不能为0")
 	}
 
 	// 判断是否申请的空间过大导致内存溢出
